## 线程的状态

java 线程有以下 5 中状态。

|   线程状态    |                             含义                             |
| :-----------: | :----------------------------------------------------------: |
|      NEW      |       新建状态，线程已经创建，但是没有执行start()方法        |
|   RUNNABLE    |  可运行状态，线程可以在JVM中运行，但是还需要等待CPU分配资源  |
|    BLOCKED    | 阻塞状态，当遇到synchronized且没有取得相应的锁，就会进入这个状态 |
|    WAITING    | 等待状态，当线程中wait()/join/Locksupport.park方法时，就会进入这个状态 |
| TIMED_WAITING | 计时等待状态，当调用Thread.sleep()或者Object.wait(xx)或者Thread.join(xx)或者LockSupport.parkNanos或者LockSupport.partUntil时，进入该状态 |
|  TERMINATED   |    线程中断状态，线程被中断或者运行结束，就会进入这个状态    |

5 种状态对应不同的方法：

![image-20201223105044900](多线程.assets/image-20201223105044900.png)

> 在上图中 `标红` 的两个状态，是操作系统中线程对应的状态，Java将这两种状态合并为 **可运行状态(RUNNABLE)**。在操作系统中 **就绪状态(READY)** 表示线程已经准备完毕，等待 CPU 分配时间片。**运行中状态(RUNNING)** 表示当线程分到时间片，线程开始正式执行。



## Thread.join()

​		当线程 A 调用线程 B 对象（bThread)的join方法，其含义是当前线程 A 等待线程 B 终止后，才从线程 A 中 bThread.join() 代码的调用处返回。线程除了 join 方法以外还提供了 join(long millis) 和 void join(long millis, int nanos) 这两个具备超时特性的方法。这两个方法的意义是如果在给定的时间内线程B没有终止。那么线程A将会从该方法中返回。

> join() 方法内部会调用 join(final long millis) 方法。



## ThreadLocal



## wait 与 sleep 区别

- wait() 是 Object 中定义的 native 方法。

  ```java
  public final native void wait(long timeout) throws InterruptedException;
  ```

  每一个类的实例都可以调用这个方法。wait() 只能在 synchronized block 中调用。它会释放 synchronized 时加在 object 上的锁。

- sleep() 是定义 Thread 中的 native 静态类方法：

  ```java
  public static native void sleep(long millis) throws InterruptedException;
  ```

  Thread.sleep() 可以在任何情况下调用。Thread.sleep() 将会暂停当前线程，并且不会释放任何锁资源。

#### 唤醒 wait 和 sleep

sleep() 方法自带 sleep 时间，时间过后，Thread 会自动被唤醒。 或者可以通过调用 interrupt() 方法来中断。

wait 的唤醒会比较复杂，我们需要调用 notify() 和 notifyAll() 方法来唤醒等待在特定 wait object 上的线程。

​		notify() 会根据线程调度的机制选择一个线程来唤醒;

​		notifyAll() 会唤醒所有等待的线程，由这些线程重新争夺资源锁。













> 引用：https://juejin.cn/post/6844903919781412877