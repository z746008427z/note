#### 锁机制

- 共享锁：其他事务可以读，但是不能写。
- 排他锁：其他事务不能读，也不能写。



#### 粒度锁

MySQL 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显现了锁机制，服务器层完全不了解存储引擎中的锁实现。



- MyISAM 和 MEMORY 采用的是表级锁。
- InnoDB 存储引擎支持表级锁，也支持行锁。默认情况下是采用行锁。



#### MyISAM 表级锁模式

- **表共享读锁**：不会阻塞其他用户对同一个表的请求，但会阻塞对同一个表的写请求。
- **表独占写锁**：会阻塞其他用户对统一表的读和写操作。



​		默认情况下，写锁比读锁拥有更高的优先级，当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。



​		这就是MyISAM 不太适合有大量的更新操作和查询操作应用的原因。因为大量的更新会使读操作很难拿到锁。从而可能永远阻塞。同时一些时间长的查询操作也许会使写操作饿死。



##### MyISAM 加表锁方法

- 在执行查询（select）语句前，会自动给涉及的表加锁。
- 在执行更新操作（update、delete、insert）前，会自动的给表加写锁。这个过程不需要用户干预，因此一般用户不需要直接用 lock table 命令给 MyISAM 来显示加锁。



#### InnoDB 行锁和表锁

​	InnoDB实现了两种类型的行锁：

- **共享锁（S）**：允许一个事务去读一行，组织其他事务获得相同数据集的排他锁。
- **排他锁（X）**：允许获得排他锁的事务更新数据，组织其他事务取得相同数据集的共享读锁和排他锁。



​	为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁，两种意向锁都是表锁。

- **意向共享锁（IS）**：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 **IS锁**。

- **意向排他锁（IX）**：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 **IX锁**。

  ![Image](C:\Users\QIXIN\AppData\Local\Temp\Image.png)



#### InnoDB 加锁方式

- 意向锁是 InnoDB 自动加锁，不需要用户干预。

- 对于update、delete、insert语句，InnoDB 会自动给涉及数据集加排他锁（X）。

- 对于普通 select 语句，InnoDB 不会加任何锁。

- 事务可以通过以下语句显示的给记录集加共享锁和排他锁：

  - 共享锁（S）：

    ```sql
    select * from table_name where ... LOCK IN SHARE MODE
    ```

    其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。

  - 排他锁（X）：

    ```sql
    select * from table_name where ... FOR UPDATE
    ```

    其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获取锁。

    

##### 隐式锁定

- InnoDB 在事务执行过程中使用两阶段提交协议。

- 随时都可以锁定，InnoDB 会根据隔离级别在需要的时候自动加锁。

- 只有在执行 commit 和 rollback 的时候才会自动释放，并且所有锁都是在同一时刻被释放。



##### 显示锁定

###### lock in share mode

```sql
select ... lock in share mode		// 共享锁
```

​		in share mode 子句的作用就是将查找的数据加上一个 share 锁，这个就是表示其他的事务智能对这些数据进行简单的 select 操作，并不能够进行 DML 操作。

###### for update

```sql
select ... for update				// 排他锁
```

​		执行这个 select 查询语句的时候，会将对应的索引访问条目进行上排他锁（X锁），也就是说这个语句对应的锁就相当于 update 带来的效果。



#### InnoDB 行锁实现方式

1. 行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 就使用表锁。
2. 不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
3. 只有执行计划真正使用了索引，才能使用行锁，即便在条件中使用了索引字段，是否用索引来检索是通过执行计划来决定的。
4. 因为行锁是对索引加的锁，不是针对记录加的锁，虽然多个 session 是访问不同行的记录，但是如果使用相同的索引，会出现锁冲突。



#### InnoDB 间隙锁

​		当我们范围条件不是相等条件检索数据，并请求共享锁和排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁。



​		对于键值在条件范围内但是不存在的记录，叫做间隙 **“GAP”**，InnoDB 也会对这个间隙进行加锁，这种锁机制就是所谓的间隙锁。



##### InnoDB 使用间隙锁目的

- 防止幻读：以满足相关隔离级别的要求。

- 满足恢复和复制的需要。

  MySQL 通过 binlog 录入执行成功的 insert、update、delete 等更新数据的 SQL 语句，并由此实现 MySQL 数据库的恢复和主从复制。



##### MySQL 恢复机制特点

1. MySQL 的恢复是 SQL 语句级的，也就是重新执行 binlog 中的语句；
2. MySQL 中的 binlog 是按照事务提交的先后顺序记录的，恢复也是按照这个顺序进行的；



##### MySQL恢复机制要求

在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读。







