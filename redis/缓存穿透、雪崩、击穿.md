## 缓存穿透

指查询一个数据库一定不存在的数据

#### 现象

如果查询一个一定不存在的对象就会每次查询数据库，而每次查询都是空，每次都不会进行缓存。恶意攻击会针对这个漏洞对数据库造成压力甚至压跨数据库，即便是使用 UUID。



#### 解决方案

1. 增加校验，查明击穿原因，id 基础校验，小于 0 直接拦截。
2. 数据库中没有的数据直接放入缓存。时间设置短期（30s），防止用户反复用同一 ID 暴力攻击。
3. 布隆过滤器。



## 缓存雪崩

指在某一个时间段，缓存集中过期失效。

#### 现象

马上十二点，很快迎来一波抢购，商品信息被集中的放入了缓存。到凌晨一点时，信息集中过期。商品信息集中落到了数据库上。对数据库服务器造成周期性压力波峰。

**缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。**



#### 解决方案

1. 缓存数据的过期时间随机，防止同一时间大量数据过期现象。
2. 如果缓存时分布式部署，将热点数据均匀分布在不同高得缓存数据库当中。
3. 设置热点数据永不过期。



## 缓存击穿

指一个 key 非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，这个 key 失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在屏障上凿开了一个洞。



#### 解决方案

1. 设置热点数据永不过期。

2. 加互斥锁。

   ```java
   // 伪代码 实际复杂的多
   public static String getData (String key) {
       // 缓存中获取数据
       String result = getDataFromRedis(key);
       // 缓存中不存在数据
       if (null == result) {
           // 获取锁，去数据库取数据
           if (reenLock.tryLock()) {
               result = getDataFromDB(key);
               // 更新缓存数据
               if(null != result) {
                   setDataToCache(key, result);
               }
               // 释放锁
               reenLock.unlock();
           } else {
               // 暂停 100ms 重新取获取数据
               Thread.sleep(100);
               result = getData(key);
           }
       }
       return result;
   }
   ```

   

## 缓存预热

系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。



#### 解决方案

1. 直接写个缓存刷新页面，上线时手工操作下。
2. 数据量不大，可以再项目启动的时候自动进行拦截。
3. 定时刷新缓存。



## 缓存更新



## 缓存降级

